#!/bin/bash
set -euo pipefail

# Claude Code Documentation Helper Script v0.3
# This script handles all /docs command functionality
# Installation path: ~/.claude-code-docs/claude-docs-helper.sh

# Fixed installation path (no need for placeholder replacement)
DOCS_PATH="$HOME/.claude-code-docs"
MANIFEST="$DOCS_PATH/docs/docs_manifest.json"
MIGRATION_INFO="$DOCS_PATH/.migration_info"

# Check if we should use colors (disabled in pipes or non-TTY)
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
    # Colors for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    # No colors
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Function to print colored output
print_color() {
    local color=$1
    shift
    if [[ -n "$color" ]]; then
        echo -e "${color}$*${NC}"
    else
        echo "$*"
    fi
}

# Function to sanitize input arguments
sanitize_input() {
    # Remove any potentially dangerous characters
    echo "$1" | sed 's/[;&|`$()]//g'
}

# Function to print documentation header
print_doc_header() {
    echo "üìö COMMUNITY MIRROR: https://github.com/ericbuess/claude-code-docs"
    echo "üìñ OFFICIAL DOCS: https://docs.anthropic.com/en/docs/claude-code"
    echo ""
}

# Function to check and display migration notice
check_migration_notice() {
    if [[ -f "$MIGRATION_INFO" ]]; then
        local migrated_from=$(jq -r '.migrated_from // ""' "$MIGRATION_INFO" 2>/dev/null)
        local user_files=$(jq -r '.user_files_detected[]? // empty' "$MIGRATION_INFO" 2>/dev/null)
        
        if [[ -n "$migrated_from" ]]; then
            print_color "$BLUE" "üì¶ Documentation has been migrated to ~/.claude-code-docs"
            
            if [[ -n "$user_files" ]]; then
                print_color "$YELLOW" ""
                print_color "$YELLOW" "‚ö†Ô∏è  Custom files preserved at: $migrated_from"
                echo "$user_files" | while read -r file; do
                    echo "  - $file"
                done
            fi
            echo ""
        fi
        
        # Remove migration info after displaying
        rm -f "$MIGRATION_INFO"
    fi
}

# Function to auto-update docs if needed
auto_update() {
    cd "$DOCS_PATH" 2>/dev/null || return 1
    
    # Get current branch
    local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    
    # Quick fetch to check for updates (fast)
    if ! git fetch --quiet origin "$BRANCH" 2>/dev/null; then
        # Fetch failed - can't sync
        return 2
    fi
    
    local LOCAL=$(git rev-parse HEAD 2>/dev/null)
    local REMOTE=$(git rev-parse origin/"$BRANCH" 2>/dev/null)
    
    if [[ "$LOCAL" != "$REMOTE" ]]; then
        # Updates available - do the pull
        echo "üîÑ Updating documentation..." >&2
        git pull --quiet origin "$BRANCH" 2>&1 | grep -v "Merge made by" || true
        
        # Check if installer needs updating
        local INSTALLER_VERSION=$(jq -r '.installer_version // "0.2"' "$MANIFEST" 2>/dev/null)
        local VERSION_INT=$(echo "$INSTALLER_VERSION" | sed 's/^0\.//')
        
        if [[ $VERSION_INT -ge 3 ]]; then
            echo "üîß Updating Claude Code Docs installer..." >&2
            ./install.sh >/dev/null 2>&1
        fi
    fi
    
    return 0  # Success (either updated or already up-to-date)
}

# Function to show documentation sync status
show_freshness() {
    print_doc_header
    # Check migration notice first
    check_migration_notice
    
    # Read manifest
    if [[ ! -f "$MANIFEST" ]]; then
        print_color "$RED" "‚ùå Error: Documentation not found at ~/.claude-code-docs"
        echo "Please reinstall with:"
        echo "curl -fsSL https://raw.githubusercontent.com/ericbuess/claude-code-docs/main/install.sh | bash"
        exit 1
    fi
    
    # Try to sync with GitHub
    auto_update
    local sync_status=$?
    
    if [[ $sync_status -eq 2 ]]; then
        print_color "$YELLOW" "‚ö†Ô∏è  Could not sync with GitHub (using local cache)"
        echo "Check your internet connection or GitHub access"
    else
        print_color "$GREEN" "‚úÖ You have the latest documentation"
    fi
    
    # Show current branch and version
    cd "$DOCS_PATH" 2>/dev/null || exit 1
    local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local installer_version=$(jq -r '.installer_version // "0.2"' "$MANIFEST" 2>/dev/null)
    
    echo "üìç Branch: ${BRANCH}"
    echo "üì¶ Version: ${installer_version}"
}

# Function to read documentation
read_doc() {
    local topic=$(sanitize_input "$1")
    local doc_path="$DOCS_PATH/docs/${topic}.md"
    
    if [[ -f "$doc_path" ]]; then
        print_doc_header
        
        # Quick check if we're up to date (0.37s)
        cd "$DOCS_PATH" 2>/dev/null || exit 1
        local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
        local VERSION=$(jq -r '.installer_version // "0.2"' "$MANIFEST" 2>/dev/null)
        
        # Do the fetch to check status
        if git fetch --quiet origin "$BRANCH" 2>/dev/null; then
            local LOCAL=$(git rev-parse HEAD 2>/dev/null)
            local REMOTE=$(git rev-parse origin/"$BRANCH" 2>/dev/null)
            
            if [[ "$LOCAL" != "$REMOTE" ]]; then
                # Need to update
                echo "üîÑ Updating to latest documentation..."
                git pull --quiet origin "$BRANCH" 2>&1 | grep -v "Merge made by" || true
                
                # Check if installer needs updating
                local INSTALLER_VERSION=$(jq -r '.installer_version // "0.2"' "$MANIFEST" 2>/dev/null)
                local VERSION_INT=$(echo "$INSTALLER_VERSION" | sed 's/^0\.//')
                
                if [[ $VERSION_INT -ge 3 ]]; then
                    ./install.sh >/dev/null 2>&1
                fi
                echo "‚úÖ Updated to latest (v$VERSION, $BRANCH)"
            else
                echo "‚úÖ You have the latest docs (v$VERSION, $BRANCH)"
            fi
        else
            echo "‚ö†Ô∏è  Could not check GitHub for updates - using cached docs (v$VERSION, $BRANCH)"
        fi
        echo ""
        
        cat "$doc_path"
        echo ""
        echo "üìñ Official page: https://docs.anthropic.com/en/docs/claude-code/$topic"
    else
        # Check if this looks like a natural language query
        if [[ "$topic" =~ ^(tell[[:space:]]me[[:space:]]about|explain|what[[:space:]]is|what[[:space:]]are|how[[:space:]]do|how[[:space:]]to|show[[:space:]]me|find|search) ]] || [[ "$topic" =~ [[:space:]].*[[:space:]] ]]; then
            print_color "$YELLOW" "üîç That looks like a search query. Let me help you find the right documentation."
            echo ""
            
            # Try to extract keywords from the query
            local keywords=$(echo "$topic" | grep -o '[a-zA-Z0-9_-]\+' | grep -v -E '^(tell|me|about|explain|what|is|are|how|do|to|show|find|search|the|for|in)$' | tr '\n' ' ')
            
            if [[ -n "$keywords" ]]; then
                echo "Searching for topics related to: $keywords"
                echo ""
                
                # Search for matching topics
                local matches=$(ls "$DOCS_PATH/docs" | grep '\.md$' | sed 's/\.md$//' | grep -i -E "$(echo $keywords | tr ' ' '|')" | sort)
                
                if [[ -n "$matches" ]]; then
                    echo "Found these related topics:"
                    echo "$matches" | sed 's/^/  ‚Ä¢ /' 
                    echo ""
                    echo "Try: /docs <topic> to read a specific document"
                else
                    echo "No exact matches found. Here are all available topics:"
                    ls "$DOCS_PATH/docs" | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
                fi
            else
                echo "Available topics:"
                ls "$DOCS_PATH/docs" | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
            fi
            echo ""
            echo "üí° Tip: Use grep to search across all docs: cd ~/.claude-code-docs && grep -r 'search term' docs/"
        else
            print_color "$RED" "‚ùå Documentation not found: $topic"
            echo ""
            echo "Available topics:"
            ls "$DOCS_PATH/docs" | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
        fi
    fi
}

# Function to list available documentation
list_docs() {
    print_doc_header
    check_migration_notice
    
    # Auto-update to ensure fresh list
    auto_update
    
    echo "Available documentation topics:"
    echo ""
    ls "$DOCS_PATH/docs" | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
    echo ""
    echo "Usage: /docs <topic> or /docs -t to check freshness"
}

# Function for hook check (auto-update)
hook_check() {
    # This is now just a passthrough since auto_update handles everything
    # Note: We could potentially start a background fetch here for parallelization,
    # but since git fetch only takes ~0.37s, the complexity isn't worth it
    exit 0
}

# Function to show what's new (concise version for Claude Code)
whats_new() {
    print_doc_header
    
    # Auto-update first (synchronous - we need latest git history)
    auto_update
    
    cd "$DOCS_PATH" 2>/dev/null || {
        print_color "$RED" "‚ùå Error: Could not access documentation directory"
        exit 1
    }
    
    echo "üìö Recent documentation updates:"
    echo ""
    
    # Get recent commits that actually updated documentation
    local doc_commits=$(git log --oneline --since="7 days ago" --grep="Update Claude Code docs" -- 'docs/*.md' 2>/dev/null | head -3)
    
    if [[ -z "$doc_commits" ]]; then
        # Fallback: look for any commits that changed docs
        doc_commits=$(git log --oneline -20 -- docs/*.md 2>/dev/null | grep -v "feat:" | grep -v "fix:" | grep -v "refactor:" | grep -v "Add TODO" | grep -v "Merge" | head -3)
    fi
    
    if [[ -z "$doc_commits" ]]; then
        echo "No recent documentation updates found."
        echo ""
        echo "‚Ä¢ Full changelog: https://github.com/ericbuess/claude-code-docs/commits/main/docs"
        return
    fi
    
    # Show each commit concisely
    while IFS= read -r commit; do
        local hash=$(echo "$commit" | cut -d' ' -f1)
        local date=$(git show -s --format=%cr "$hash")
        
        print_color "$BLUE" "‚Ä¢ $date:"
        echo "  üìé https://github.com/ericbuess/claude-code-docs/commit/$hash"
        
        # Show which docs changed with inline links
        local changed_docs=$(git diff-tree --no-commit-id --name-only -r "$hash" -- docs/*.md | sed 's|docs/||' | sed 's|\.md$||' | head -5)
        if [[ -n "$changed_docs" ]]; then
            echo "$changed_docs" | while read -r doc; do
                [[ -n "$doc" ]] && echo "  üìÑ $doc: https://docs.anthropic.com/en/docs/claude-code/$doc"
                
                # Show one key change per doc
                local diff_output=$(git diff "${hash}^..${hash}" -- "docs/${doc}.md" 2>/dev/null || echo "")
                local added_section=$(echo "$diff_output" | grep '^+#' | sed 's/^+//' | sed 's/^#* *//' | head -1)
                if [[ -n "$added_section" ]]; then
                    echo "     ‚ûï Added: $added_section"
                else
                    local key_change=$(echo "$diff_output" | grep -E '^\+.*\b(new|added|feature|command|option|support|enable|integration)\b' -i | sed 's/^+//' | sed 's/^[[:space:]]*//' | head -1)
                    if [[ -n "$key_change" ]]; then
                        echo "     ‚ú® ${key_change:0:60}..."
                    fi
                fi
            done
        fi
        echo ""
    done <<< "$doc_commits"
    
    echo "üìé Full changelog: https://github.com/ericbuess/claude-code-docs/commits/main/docs"
    echo "üìö COMMUNITY MIRROR - NOT AFFILIATED WITH ANTHROPIC"
}

# Function for uninstall
uninstall() {
    print_doc_header
    print_color "$GREEN" "Claude Code Documentation Mirror - Uninstaller"
    print_color "$GREEN" "=============================================="
    echo ""
    
    print_color "$YELLOW" "This will remove:"
    echo "  ‚Ä¢ The /docs command from ~/.claude/commands/docs.md"
    echo "  ‚Ä¢ The auto-update hook from ~/.claude/settings.json"
    echo "  ‚Ä¢ The installation directory ~/.claude-code-docs"
    echo ""
    
    # Ask for confirmation
    read -p "Are you sure you want to uninstall? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_color "$YELLOW" "Uninstall cancelled."
        exit 0
    fi
    
    # Remove command file
    if [[ -f ~/.claude/commands/docs.md ]]; then
        rm -f ~/.claude/commands/docs.md
        print_color "$GREEN" "‚úì Removed /docs command"
    fi
    
    # Remove hook from settings.json
    if [[ -f ~/.claude/settings.json ]]; then
        # Backup first
        cp ~/.claude/settings.json ~/.claude/settings.json.backup
        
        # Remove any hooks that contain our path (check both expanded and ~ versions)
        if jq '.hooks.PreToolUse = [(.hooks.PreToolUse // [])[] | select(.hooks[0].command | contains("/.claude-code-docs/") | not)]' ~/.claude/settings.json > ~/.claude/settings.json.tmp; then
            # Clean up empty arrays/objects
            jq 'if .hooks.PreToolUse == [] then .hooks |= if . == {PreToolUse: []} then {} else del(.PreToolUse) end else . end | if .hooks == {} then del(.hooks) else . end' ~/.claude/settings.json.tmp > ~/.claude/settings.json.tmp2
            mv ~/.claude/settings.json.tmp2 ~/.claude/settings.json
            rm -f ~/.claude/settings.json.tmp
            print_color "$GREEN" "‚úì Removed hooks from settings"
        else
            print_color "$RED" "Failed to update settings.json"
            rm -f ~/.claude/settings.json.tmp
        fi
    fi
    
    # Remove installation directory
    print_color "$YELLOW" "Removing installation directory..."
    cd ~
    rm -rf "$DOCS_PATH"
    print_color "$GREEN" "‚úì Removed installation directory"
    
    echo ""
    print_color "$GREEN" "‚úÖ Claude Code Documentation Mirror has been uninstalled!"
    echo ""
    echo "To reinstall:"
    echo "curl -fsSL https://raw.githubusercontent.com/ericbuess/claude-code-docs/main/install.sh | bash"
}

# Combine all arguments into one string for easier parsing
# Also clean up any escaped quotes that might come from Claude Code
FULL_ARGS="$*"
FULL_ARGS="${FULL_ARGS//\\\'/\'}"  # Replace \' with '
FULL_ARGS="${FULL_ARGS//\\\"/\"}"  # Replace \" with "

# Check if arguments start with -t flag (Claude Code passes all args as one string)
if [[ "$FULL_ARGS" =~ ^-t\ +(.*)$ ]] || [[ "$FULL_ARGS" =~ ^--check\ +(.*)$ ]]; then
    show_freshness
    remaining_args="${BASH_REMATCH[1]}"
    if [[ "$remaining_args" =~ ^what.?s?\ ?new.*$ ]]; then
        echo ""
        whats_new
    elif [[ -n "$remaining_args" ]]; then
        echo ""
        read_doc "$(sanitize_input "$remaining_args")"
    fi
    exit 0
elif [[ "$FULL_ARGS" == "-t" ]] || [[ "$FULL_ARGS" == "--check" ]]; then
    show_freshness
    exit 0
fi

# Main command handling
case "${1:-}" in
    -t|--check)
        show_freshness
        # Check if remaining args form "what's new"
        shift
        remaining_args="$*"
        if [[ "$remaining_args" =~ ^what.?s?\ ?new.*$ ]]; then
            echo ""
            whats_new
        elif [[ -n "$remaining_args" ]]; then
            echo ""
            read_doc "$(sanitize_input "$remaining_args")"
        fi
        ;;
    hook-check)
        hook_check
        ;;
    uninstall)
        uninstall
        ;;
    "whats-new"|"what's-new"|"whatsnew"|"what's new"|"whats"|"what"|"whats-new?"|"what's-new?")
        # Handle various forms of "what's new"
        if [[ "${2:-}" == "new" ]] || [[ "$FULL_ARGS" =~ new ]]; then
            whats_new
        else
            # Just "what" without "new" - treat as doc lookup
            read_doc "$1"
        fi
        ;;
    "")
        list_docs
        ;;
    *)
        # Check if the full arguments match "what's new" pattern
        # Be very flexible to handle various quote escaping issues
        if [[ "$FULL_ARGS" =~ what.*new ]] || [[ "$1 ${2:-}" =~ what.*new ]]; then
            whats_new
        else
            # Default: read documentation (header printed in read_doc)
            read_doc "$1"
        fi
        ;;
esac